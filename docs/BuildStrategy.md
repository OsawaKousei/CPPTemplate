# ビルド戦略と開発ワークフロー

## 1. 概要

本プロジェクトでは、開発の利便性とビルドの再現性を両立させるため、**DevContainer** と **使い捨てのビルド用コンテナ** を組み合わせたハイブリッドな戦略を採用しています。

## 2. 環境構成と役割分担

| 環境                  | 役割                                                                      | 主なツール/操作                            |
| :-------------------- | :------------------------------------------------------------------------ | :----------------------------------------- |
| **ホスト OS** (Linux) | ・ソースコードの永続化<br>・ビルドスクリプトの実行<br>・成果物の実行      | `git`, `./scripts/build.sh`, `./build/app` |
| **DevContainer**      | ・コーディング<br>・インテリセンス (LSP)<br>・コードフォーマット/静的解析 | VS Code, C++ Extension, Clang-Tidy         |
| **ビルド用コンテナ**  | ・クリーンビルドの実行<br>・依存関係の解決<br>・コンパイル                | Docker, CMake, GCC/Clang                   |

## 3. 詳細ワークフロー

### 3.1 コーディング (DevContainer)

開発者は VS Code の DevContainer 機能を使用して、コンテナ化された開発環境に接続します。

- **メリット**: 開発者全員が同一のコンパイラバージョン、ツールチェーンを使用するため、環境差異によるトラブルが発生しません。
- **インテリセンス**: `CMakeLists.txt` の `CMAKE_EXPORT_COMPILE_COMMANDS` 設定により、コンテナ内のパス構成に基づいた正確な補完機能が働きます。

### 3.2 ビルド (Build Container)

ビルドはホスト側から `scripts/build.sh` を実行することで行います。
このスクリプトは以下の手順を自動化しています：

1.  ビルド専用の Docker イメージを構築（または更新）。
2.  コンテナを起動し、ソースコードをマウント。
3.  コンテナ内で `cmake` ビルドを実行。
4.  生成されたバイナリをホスト側の `build/` ディレクトリに出力。
5.  コンテナを破棄。

**ポイント**: `docker run` 時に `--user $(id -u):$(id -g)` を指定することで、コンテナ内で生成されるファイルの所有者がホスト側のユーザーとなり、権限トラブルを防いでいます。

### 3.3 実行 (Host)

ビルド成果物（実行ファイル）はホスト側の `build/app` に生成されます。これをホスト OS 上で直接実行します。

## 4. この戦略の利点

1.  **環境汚染の防止**: ホスト OS に特定のコンパイラやライブラリをインストールする必要がありません（Docker のみ必要）。
2.  **CI/CD との整合性**: ビルド用コンテナの定義 (`Dockerfile`) は CI 環境でもそのまま利用できるため、ローカルビルドと CI ビルドの完全な一致が保証されます。
3.  **高い開発体験**: エディタ操作は高速な DevContainer で行いつつ、ビルドは隔離された環境で行うことで、安定した開発サイクルを実現します。

## 5. 注意事項

- **Sanitizer の依存**: 現在のビルド設定では AddressSanitizer 等が有効になっています。ホスト側で実行する際、ホスト環境に該当するランタイムライブラリ（例: `libasan`）がインストールされていない場合、実行時エラーになる可能性があります。
- **インテリセンスの初期化**: 初回起動時は `compile_commands.json` が存在しないため、一度ビルドを実行するか、DevContainer 内で CMake の Configure を行う必要があります。
