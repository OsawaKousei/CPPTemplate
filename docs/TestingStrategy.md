# **モダンC++テスト戦略ガイドライン**

本ドキュメントは、既存のコーディング規約に基づき、堅牢でメンテナンス性の高いコードを実現するためのテスト方針を定めます。

## **1\. テスト設計の基本原則**

### **1.1 Service Object の機能検証に集中する**

* **Data Object (Aggregate Struct)** はロジックを持たないため、原則として単体テストは不要です   
* **Service Object** は状態を持たず（Stateless）、入出力が明確であるため、純粋関数に近い形でテストを実施します

### **1.2 不変性を活かしたアサーション**

* 「既存の変更」ではなく「新しい値の生成」を原則とするため、テストでは関数の戻り値が期待通りであるかを検証する「値ベースのテスト」を優先します 

## **2\. 単体テストの実装指針**

### **2.1 Dependency Injection (DI) の活用**

* Service Object は依存関係をコンストラクタで受け取るため、テスト時にはモック（Mock）やスタブ（Stub）の注入が容易です  
* インターフェース（純粋仮想関数のみの抽象クラス）を継承したモッククラスを作成し、外部リソース（DB、通信等）をシミュレートします

### **2.2 Result パターン (tl::expected) の検証**

* 例外ではなく tl::expected\<T, E\> を戻り値とするため、テストでは以下の両方のケースを明示的に検証する必要があります  
  * **正常系**: .has\_value() が true であり、期待される値が含まれていること  
  * **異常系**: .has\_value() が false であり、適切なエラーコード（unexpected）が返されること

### **2.3 Ranges / IIFE のテスト**

* 複雑なデータ変換（std::ranges や IIFE）を行うロジックは、ヘルパー関数として抽出することを検討し、その変換結果が正しいかを検証します

* std::span\<const T\> を引数に取る関数をテストする場合、一時的な std::vector を作成して渡すことで、メモリ効率とテストの書きやすさを両立させます

## ---

**3\. 推奨ツールとライブラリ**

| カテゴリ | 推奨ツール |
| :---- | :---- |
| **テストフレームワーク** | **GoogleTest** |
| **モックライブラリ** | **gMock** |
| **カバレッジ計測** | **Gcov** |

## ---

**4\. 自動化と品質担保**

### **4.1 静的・動的解析の統合**

* **Clang-Tidy**: modernize-\* チェックを CI に組み込み、規約違反（生ポインタの使用など）を自動検知します  
* **Sanitizers**: 実行時テストにおいて、AddressSanitizer (ASan) や UndefinedBehaviorSanitizer (UBSan) を有効にし、メモリ問題や未定義動作を検出します

### **4.2 テストコードの命名規則**

* テストファイル名: 対象ファイル名\_test.cpp （例: user\_repository\_test.cpp  
* テストケース名: PascalCase で記述し、何が\_どうなるべきか を明確にします。  
  * 例: TEST\_F(UserServiceTest, GetUser\_ReturnsError\_WhenUserNotFound)

## ---

**5\. テストすべき/すべきでない事項の整理**

| 対象 | テストの要否 | 注記 |
| :---- | :---- | :---- |
| **Data Object** | 不要 | メンバ変数へのアクセスのみであるため  |
| **Service (Logic)** | **必須** |  tl::expected を用いた分岐網羅を確認  |
| **Resource (IO)** | 必要 | モックを使用して、境界条件（通信失敗等）をテスト |
| **std::vector / span** | 不要 | 標準ライブラリ自体の動作テストは行わない  |

